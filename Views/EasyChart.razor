@using System.Globalization;
@using RadzenHelper.DisplayHelper;
@using RadzenHelper.Extensions;

@if (ShowOptionsCard)
{
    <RadzenCard Class="w-100 mb-4" Style="display: flex; align-items: center; gap: 0.5rem">
        <RadzenCheckBox @bind-Value="@Trend" Name="Trend"></RadzenCheckBox>
        <RadzenLabel Text="Trend" For="Trend" Style="margin-right: 1rem;" Class="rz-color-danger-dark" />
        <RadzenCheckBox @bind-Value="@Median" Name="Median"></RadzenCheckBox>
        <RadzenLabel Text="Median" For="Median" Style="margin-right: 1rem;" Class="rz-color-success-dark" />
        <RadzenCheckBox @bind-Value="@Mean" Name="Mean"></RadzenCheckBox>
        <RadzenLabel Text="Mean" For="Mean" Style="margin-right: 1rem;" Class="rz-color-info-dark" />
        <RadzenCheckBox @bind-Value="@Mode" Name="Mode"></RadzenCheckBox>
        <RadzenLabel Text="Mode" For="Mode" Class="rz-color-warning-darker" />
    </RadzenCard>
}

@if (isLoading)
{
    @("Daten werden ausgewertet...")
    @*<RadzenIcon Icon="@(MaterialIcons.HourglassFull)" class="loading"/>*@
    @*<svg width="75" height="75" viewBox="0 0 100 100" class="loading">
        <polyline class="line-cornered stroke-still" points="0,0 100,0 100,100" stroke-width="10" fill="none"></polyline>
        <polyline class="line-cornered stroke-still" points="0,0 0,100 100,100" stroke-width="10" fill="none"></polyline>
        <polyline class="line-cornered stroke-animation" points="0,0 100,0 100,100" stroke-width="10" fill="none"></polyline>
        <polyline class="line-cornered stroke-animation" points="0,0 0,100 100,100" stroke-width="10" fill="none"></polyline>
    </svg>*@
}
<RadzenChart @ref="chartRef">
    <RadzenLineSeries Smooth="true" Data="@ChartValues" Title="MW" CategoryProperty="ValueX" ValueProperty="ValueY" RenderingOrder="1">
        <RadzenSeriesTrendLine Visible="@Trend" Stroke="var(--rz-danger-dark)" LineType="LineType.Dashed" />
        <RadzenSeriesMedianLine Visible="@Median" Stroke="var(--rz-success-dark)" LineType="LineType.Dotted" />
        <RadzenSeriesMeanLine Visible="@Mean" Stroke="var(--rz-info-dark)" LineType="LineType.Dotted" />
        <RadzenSeriesModeLine Visible="@Mode" Stroke="var(--rz-warning-darker)" LineType="LineType.Dotted" />
    </RadzenLineSeries>
    <RadzenCategoryAxis Padding="20" Formatter="@FormatValueX">
        <RadzenGridLines Visible="false" />
        <RadzenAxisTitle Text="@AxisTextY" />
    </RadzenCategoryAxis>
    <RadzenValueAxis Formatter="@FormatValueY" Min="0">
        <RadzenGridLines Visible="true" />
        <RadzenAxisTitle Text="@AxisTextX" />
    </RadzenValueAxis>
</RadzenChart>

@code {
    RadzenChart? chartRef;

    List<ChartValueBase> chartValues = new();

    int pos = 0;
    bool isLoading = true;

    [Parameter]
    public bool Trend { get; set; } = true;
    [Parameter]
    public bool Median { get; set; } = false;
    [Parameter]
    public bool Mean { get; set; } = false;
    [Parameter]
    public bool Mode { get; set; } = false;

    [Parameter]
    public bool ShowOptionsCard { get; set; } = false;

    [Parameter]
    public int NumberOfLabels { get; set; } = 7;

    [Parameter]
    public string AxisTextY { get; set; } = "";
    [Parameter]
    public string AxisTextX { get; set; } = "";

    [Parameter]
    public int MaxEntries { get; set; } = 150;

    [Parameter]
    public List<ChartValueBase> Values { get; set; } = new();

    public List<ChartValueBase> ChartValues => chartValues;


    public void Refresh()
    {
        isLoading = true;
        StateHasChanged();
    }

    protected async override Task OnParametersSetAsync()
    {
        base.OnParametersSet();

        if (!isLoading)
        {
            return;
        }

        if (Values.Count != 0 && Values.Count < MaxEntries)
        {
            isLoading = false;
            ChartValues.ReplaceValues(Values);
        }
        else
        {
            var each = Values.Count / MaxEntries;
            ChartValues.ReplaceValues(Values.GetNth(each));
        }

        if (chartRef != null)
        {
            await chartRef.Reload();
        }
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (isLoading && Values.Count >= MaxEntries)
        {
            await Task.Run(() => ChartValues.ReplaceValues<ChartValueBase>(GetChartValues()));
            if (chartRef != null)
            {
                isLoading = false;
                await chartRef.Reload();
                StateHasChanged();
            }
        }
    }

    private List<ChartValueBase> GetChartValues()
    {
        pos = 0;

        List<ChartValueBase> result;
        if (Values.Count <= MaxEntries)
        {
            result = Values;
        }
        else
        {
            result = Values.SplitIntoNChunks<ChartValueBase>(MaxEntries)
                        .Select(list =>
                            new ChartValueBase
                                {
                                    ValueX = list.FirstOrDefault(x => x != null)?.ValueX ?? "",
                                    ValueY = list.Average(v => v.ValueY)
                                }).ToList();
        }
        return result;
    }

    string FormatValueY(object value)
    {
        return value?.ToString() ?? "";
    }

    string FormatValueX(object value)
    {
        var str = value?.ToString();
        if (!string.IsNullOrEmpty(str))
        {
            var shouldDisplay = (pos++ % (Math.Min(ChartValues.Count, MaxEntries) / NumberOfLabels)) == 0;
            return shouldDisplay ? str : "";
        }
        return "";
    }
}